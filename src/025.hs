import Data.Maybe
import Data.Fixed
import Data.List (foldl')
import System.Environment

fastFindIndex cond xs prev now
  | prev==now    &&     matchNow  = Just now
  | prev==now    && not matchNow  = Nothing
  | not matchNow && not matchPrev = fastFindIndex cond xs now (now+(now-prev)*2)
  | not matchNow &&     matchPrev = fastFindIndex cond xs now (now-(now-prev)`div`2)
  |     matchNow && not matchPrev = fastFindIndex cond xs now (now-(now-prev)`div`2)
  |     matchNow &&     matchPrev = fastFindIndex cond xs now (now+(now-prev)`div`2) where
    matchNow  = cond(xs now)  == True
    matchPrev = cond(xs prev) == True

fib :: Int -> BigN
fib i = (phi^i) / sqrt5

phi :: BigN
phi = (1+sqrt5) / 2

sqrt5 :: BigN
sqrt5=2.2360679774997896964091736687312762354406183596115257242708972454105209256378048994144144083787822749695081761507737835042532677244470738635863601215334527088667781731918791658112766453226398565805357613504175337850034233924140644420864325390972525926272288762995174024406816117759089094984923713907297288984820886415426898940991316935770197486788844250897541329561831769214999774248015304341150359576683325124988151781394080005624208552435422355561063063428202340933319829339597463522712013417496142026359047378855043896870611356600457571399565955669569175645782219525000605392312340050092867648755297220567662536660744858535052623306784946334222423176372770266324076801044433158257335058930981362263431986864719469899701808189524264459620345221411922329125981963258111041704958070481204034559949435068555518555725123886416550102624363125710244496187894246829034044747161154557232017376765904609185295756035779843980541553807790643936397230287560629994822138521773485924535

data E1001=E1001
instance HasResolution E1001 where
    resolution _ = 10 ^ 1001
type BigN= Fixed E1001

main = do
  args <- getArgs
  let t = read (head args)
  print $ answer $ 10^t
answer x = fastFindIndex (\y->y>x) fib 0 1


-- fib n = (power fn n - power fn (-n)) / sqrt(5)
--   where fn = (1+sqrt(5)) / 2

power :: (Integral a, Floating b) => a -> b
power x y | y>0 = x * power x (y-1)
          | y<0 = 1 / power x (y+1)
          | otherwise = 1
